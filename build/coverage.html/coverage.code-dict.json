{"/home/travis/build/npmtest/node-npmtest-yargs/test.js":"/* istanbul instrument in package npmtest_yargs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yargs/lib.npmtest_yargs.js":"/* istanbul instrument in package npmtest_yargs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_yargs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_yargs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-yargs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-yargs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_yargs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_yargs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_yargs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_yargs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_yargs.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_yargs.__dirname +\n                    '/lib.npmtest_yargs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/index.js":"// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst yargs = require('./yargs')\n\nArgv(process.argv.slice(2))\n\nmodule.exports = Argv\n\nfunction Argv (processArgs, cwd) {\n  const argv = yargs(processArgs, cwd, require)\n  singletonify(argv)\n  return argv\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify (inst) {\n  Object.keys(inst).forEach(function (key) {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key))\n    } else {\n      Argv[key] = typeof inst[key] === 'function' ? inst[key].bind(inst) : inst[key]\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/yargs.js":"const argsert = require('./lib/argsert')\nconst assign = require('./lib/assign')\nconst Command = require('./lib/command')\nconst Completion = require('./lib/completion')\nconst Parser = require('yargs-parser')\nconst path = require('path')\nconst Usage = require('./lib/usage')\nconst Validation = require('./lib/validation')\nconst Y18n = require('y18n')\nconst objFilter = require('./lib/obj-filter')\nconst setBlocking = require('set-blocking')\nconst applyExtends = require('./lib/apply-extends')\nconst YError = require('./lib/yerror')\n\nvar exports = module.exports = Yargs\nfunction Yargs (processArgs, cwd, parentRequire) {\n  processArgs = processArgs || [] // handle calling yargs().\n\n  const self = {}\n  var command = null\n  var completion = null\n  var groups = {}\n  var output = ''\n  var preservedGroups = {}\n  var usage = null\n  var validation = null\n\n  const y18n = Y18n({\n    directory: path.resolve(__dirname, './locales'),\n    updateFiles: false\n  })\n\n  if (!cwd) cwd = process.cwd()\n\n  self.$0 = process.argv\n    .slice(0, 2)\n    .map(function (x, i) {\n      // ignore the node bin, specify this in your\n      // bin file with #!/usr/bin/env node\n      if (i === 0 && /\\b(node|iojs)(\\.exe)?$/.test(x)) return\n      var b = rebase(cwd, x)\n      return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x\n    })\n    .join(' ').trim()\n\n  if (process.env._ !== undefined && process.argv[1] === process.env._) {\n    self.$0 = process.env._.replace(\n      path.dirname(process.execPath) + '/', ''\n    )\n  }\n\n  // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n  const context = { resets: -1, commands: [], files: [] }\n  self.getContext = function () {\n    return context\n  }\n\n  // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n  var options\n  self.resetOptions = self.reset = function (aliases) {\n    context.resets++\n    aliases = aliases || {}\n    options = options || {}\n    // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n    var tmpOptions = {}\n    tmpOptions.local = options.local ? options.local : []\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : []\n\n    // if a key has been explicitly set as local,\n    // we should reset it before passing options to command.\n    var localLookup = {}\n    tmpOptions.local.forEach(function (l) {\n      localLookup[l] = true\n      ;(aliases[l] || []).forEach(function (a) {\n        localLookup[a] = true\n      })\n    })\n\n    // preserve all groups not set to local.\n    preservedGroups = Object.keys(groups).reduce(function (acc, groupName) {\n      var keys = groups[groupName].filter(function (key) {\n        return !(key in localLookup)\n      })\n      if (keys.length > 0) {\n        acc[groupName] = keys\n      }\n      return acc\n    }, {})\n    // groups can now be reset\n    groups = {}\n\n    var arrayOptions = [\n      'array', 'boolean', 'string', 'requiresArg', 'skipValidation',\n      'count', 'normalize', 'number'\n    ]\n\n    var objectOptions = [\n      'narg', 'key', 'alias', 'default', 'defaultDescription',\n      'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce'\n    ]\n\n    arrayOptions.forEach(function (k) {\n      tmpOptions[k] = (options[k] || []).filter(function (k) {\n        return !localLookup[k]\n      })\n    })\n\n    objectOptions.forEach(function (k) {\n      tmpOptions[k] = objFilter(options[k], function (k, v) {\n        return !localLookup[k]\n      })\n    })\n\n    tmpOptions.envPrefix = options.envPrefix\n    options = tmpOptions\n\n    // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n    usage = usage ? usage.reset(localLookup) : Usage(self, y18n)\n    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n)\n    command = command ? command.reset() : Command(self, usage, validation)\n    if (!completion) completion = Completion(self, usage, command)\n\n    if (!strictGlobal) strict = false\n    completionCommand = null\n    output = ''\n    exitError = null\n    hasOutput = false\n    self.parsed = false\n\n    return self\n  }\n  self.resetOptions()\n\n  // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n  var frozen\n  function freeze () {\n    frozen = {}\n    frozen.options = options\n    frozen.configObjects = options.configObjects.slice(0)\n    frozen.exitProcess = exitProcess\n    frozen.groups = groups\n    usage.freeze()\n    validation.freeze()\n    command.freeze()\n    frozen.strict = strict\n    frozen.completionCommand = completionCommand\n    frozen.output = output\n    frozen.exitError = exitError\n    frozen.hasOutput = hasOutput\n    frozen.parsed = self.parsed\n  }\n  function unfreeze () {\n    options = frozen.options\n    options.configObjects = frozen.configObjects\n    exitProcess = frozen.exitProcess\n    groups = frozen.groups\n    output = frozen.output\n    exitError = frozen.exitError\n    hasOutput = frozen.hasOutput\n    self.parsed = frozen.parsed\n    usage.unfreeze()\n    validation.unfreeze()\n    command.unfreeze()\n    strict = frozen.strict\n    completionCommand = frozen.completionCommand\n    parseFn = null\n    parseContext = null\n    frozen = undefined\n  }\n\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('boolean', keys)\n    return self\n  }\n\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('array', keys)\n    return self\n  }\n\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('number', keys)\n    return self\n  }\n\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('normalize', keys)\n    return self\n  }\n\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('count', keys)\n    return self\n  }\n\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('string', keys)\n    return self\n  }\n\n  self.requiresArg = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('requiresArg', keys)\n    return self\n  }\n\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('skipValidation', keys)\n    return self\n  }\n\n  function populateParserHintArray (type, keys, value) {\n    keys = [].concat(keys)\n    keys.forEach(function (key) {\n      options[type].push(key)\n    })\n  }\n\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length)\n    populateParserHintObject(self.nargs, false, 'narg', key, value)\n    return self\n  }\n\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length)\n    populateParserHintObject(self.choices, true, 'choices', key, value)\n    return self\n  }\n\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length)\n    populateParserHintObject(self.alias, true, 'alias', key, value)\n    return self\n  }\n\n  // TODO: actually deprecate self.defaults.\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length)\n    if (defaultDescription) options.defaultDescription[key] = defaultDescription\n    if (typeof value === 'function') {\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value)\n      value = value.call()\n    }\n    populateParserHintObject(self.default, false, 'default', key, value)\n    return self\n  }\n\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length)\n    populateParserHintObject(self.describe, false, 'key', key, true)\n    usage.describe(key, desc)\n    return self\n  }\n\n  self.demandOption = function (keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length)\n    populateParserHintObject(self.demandOption, false, 'demandedOptions', keys, msg)\n    return self\n  }\n\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length)\n    populateParserHintObject(self.coerce, false, 'coerce', keys, value)\n    return self\n  }\n\n  function populateParserHintObject (builder, isArray, type, key, value) {\n    if (Array.isArray(key)) {\n      // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n      var temp = {}\n      key.forEach(function (k) {\n        temp[k] = value\n      })\n      builder(temp)\n    } else if (typeof key === 'object') {\n      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n      Object.keys(key).forEach(function (k) {\n        builder(k, key[k])\n      })\n    } else {\n      // a single key value pair 'x', parse() {}\n      if (isArray) {\n        options[type][key] = (options[type][key] || []).concat(value)\n      } else {\n        options[type][key] = value\n      }\n    }\n  }\n\n  self.config = function (key, msg, parseFn) {\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length)\n    // allow a config object to be provided directly.\n    if (typeof key === 'object') {\n      key = applyExtends(key, cwd)\n      options.configObjects = (options.configObjects || []).concat(key)\n      return self\n    }\n\n    // allow for a custom parsing function.\n    if (typeof msg === 'function') {\n      parseFn = msg\n      msg = null\n    }\n\n    key = key || 'config'\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'))\n    ;(Array.isArray(key) ? key : [key]).forEach(function (k) {\n      options.config[k] = parseFn || true\n    })\n\n    return self\n  }\n\n  self.example = function (cmd, description) {\n    argsert('<string> [string]', [cmd, description], arguments.length)\n    usage.example(cmd, description)\n    return self\n  }\n\n  self.command = function (cmd, description, builder, handler) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function]', [cmd, description, builder, handler], arguments.length)\n    command.addHandler(cmd, description, builder, handler)\n    return self\n  }\n\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length)\n    const req = parentRequire || require\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts)\n    return self\n  }\n\n  // TODO: deprecate self.demand in favor of\n  // .demandCommand() .demandOption().\n  self.demand = self.required = self.require = function (keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n    if (Array.isArray(max)) {\n      max.forEach(function (key) {\n        self.demandOption(key, msg)\n      })\n      max = Infinity\n    } else if (typeof max !== 'number') {\n      msg = max\n      max = Infinity\n    }\n\n    if (typeof keys === 'number') {\n      self.demandCommand(keys, max, msg, msg)\n    } else if (Array.isArray(keys)) {\n      keys.forEach(function (key) {\n        self.demandOption(key, msg)\n      })\n    } else {\n      if (typeof msg === 'string') {\n        self.demandOption(keys, msg)\n      } else if (msg === true || typeof msg === 'undefined') {\n        self.demandOption(keys)\n      }\n    }\n\n    return self\n  }\n\n  self.demandCommand = function (min, max, minMsg, maxMsg) {\n    argsert('[number] [number|string] [string|null] [string|null]', [min, max, minMsg, maxMsg], arguments.length)\n\n    if (typeof min === 'undefined') min = 1\n\n    if (typeof max !== 'number') {\n      minMsg = max\n      max = Infinity\n    }\n\n    self.global('_', false)\n\n    options.demandedCommands._ = {\n      min: min,\n      max: max,\n      minMsg: minMsg,\n      maxMsg: maxMsg\n    }\n\n    return self\n  }\n\n  self.getDemandedOptions = function () {\n    argsert([], 0)\n    return options.demandedOptions\n  }\n\n  self.getDemandedCommands = function () {\n    argsert([], 0)\n    return options.demandedCommands\n  }\n\n  self.implies = function (key, value) {\n    argsert('<string|object> [string]', [key, value], arguments.length)\n    validation.implies(key, value)\n    return self\n  }\n\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string]', [key1, key2], arguments.length)\n    validation.conflicts(key1, key2)\n    return self\n  }\n\n  self.usage = function (msg, opts) {\n    argsert('<string|null|object> [object]', [msg, opts], arguments.length)\n\n    if (!opts && typeof msg === 'object') {\n      opts = msg\n      msg = null\n    }\n\n    usage.usage(msg)\n\n    if (opts) self.options(opts)\n\n    return self\n  }\n\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length)\n    usage.epilog(msg)\n    return self\n  }\n\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length)\n    usage.failFn(f)\n    return self\n  }\n\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length)\n    validation.check(f, _global !== false)\n    return self\n  }\n\n  self.global = function (globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length)\n    globals = [].concat(globals)\n    if (global !== false) {\n      options.local = options.local.filter(function (l) {\n        return globals.indexOf(l) === -1\n      })\n    } else {\n      globals.forEach(function (g) {\n        if (options.local.indexOf(g) === -1) options.local.push(g)\n      })\n    }\n    return self\n  }\n\n  self.pkgConf = function (key, path) {\n    argsert('<string> [string]', [key, path], arguments.length)\n    var conf = null\n    // prefer cwd to require-main-filename in this method\n    // since we're looking for e.g. \"nyc\" config in nyc consumer\n    // rather than \"yargs\" config in nyc (where nyc is the main filename)\n    var obj = pkgUp(path || cwd)\n\n    // If an object exists in the key, add it to options.configObjects\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], path || cwd, key)\n      options.configObjects = (options.configObjects || []).concat(conf)\n    }\n\n    return self\n  }\n\n  var pkgs = {}\n  function pkgUp (path) {\n    var npath = path || '*'\n    if (pkgs[npath]) return pkgs[npath]\n    const readPkgUp = require('read-pkg-up')\n\n    var obj = {}\n    try {\n      obj = readPkgUp.sync({\n        cwd: path || require('require-main-filename')(parentRequire || require),\n        normalize: false\n      })\n    } catch (noop) {}\n\n    pkgs[npath] = obj.pkg || {}\n    return pkgs[npath]\n  }\n\n  var parseFn = null\n  var parseContext = null\n  self.parse = function (args, shortCircuit, _parseFn) {\n    argsert('<string|array> [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length)\n\n    // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit\n      shortCircuit = _parseFn\n    }\n\n    // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit\n      shortCircuit = null\n    }\n    // completion short-circuits the parsing process,\n    // skipping validation, etc.\n    if (!shortCircuit) processArgs = args\n\n    freeze()\n    if (parseFn) exitProcess = false\n\n    var parsed = self._parseArgs(args, shortCircuit)\n    if (parseFn) parseFn(exitError, parsed, output)\n    unfreeze()\n\n    return parsed\n  }\n\n  self._getParseContext = function () {\n    return parseContext || {}\n  }\n\n  self._hasParseCallback = function () {\n    return !!parseFn\n  }\n\n  self.option = self.options = function (key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length)\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.options(k, key[k])\n      })\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {}\n      }\n\n      options.key[key] = true // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias)\n\n      var demand = opt.demand || opt.required || opt.require\n\n      // deprecated, use 'demandOption' instead\n      if (demand) {\n        self.demand(key, demand)\n      }\n\n      if ('demandOption' in opt) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined)\n      }\n\n      if ('config' in opt) {\n        self.config(key, opt.configParser)\n      }\n\n      if ('conflicts' in opt) {\n        self.conflicts(key, opt.conflicts)\n      }\n\n      if ('default' in opt) {\n        self.default(key, opt.default)\n      }\n\n      if ('implies' in opt) {\n        self.implies(key, opt.implies)\n      }\n\n      if ('nargs' in opt) {\n        self.nargs(key, opt.nargs)\n      }\n\n      if ('normalize' in opt) {\n        self.normalize(key)\n      }\n\n      if ('choices' in opt) {\n        self.choices(key, opt.choices)\n      }\n\n      if ('coerce' in opt) {\n        self.coerce(key, opt.coerce)\n      }\n\n      if ('group' in opt) {\n        self.group(key, opt.group)\n      }\n\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key)\n        if (opt.alias) self.boolean(opt.alias)\n      }\n\n      if (opt.array || opt.type === 'array') {\n        self.array(key)\n        if (opt.alias) self.array(opt.alias)\n      }\n\n      if (opt.number || opt.type === 'number') {\n        self.number(key)\n        if (opt.alias) self.number(opt.alias)\n      }\n\n      if (opt.string || opt.type === 'string') {\n        self.string(key)\n        if (opt.alias) self.string(opt.alias)\n      }\n\n      if (opt.count || opt.type === 'count') {\n        self.count(key)\n      }\n\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global)\n      }\n\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription\n      }\n\n      if (opt.skipValidation) {\n        self.skipValidation(key)\n      }\n\n      var desc = opt.describe || opt.description || opt.desc\n      if (desc) {\n        self.describe(key, desc)\n      }\n\n      if (opt.requiresArg) {\n        self.requiresArg(key)\n      }\n    }\n\n    return self\n  }\n  self.getOptions = function () {\n    return options\n  }\n\n  self.group = function (opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length)\n    var existing = preservedGroups[groupName] || groups[groupName]\n    if (preservedGroups[groupName]) {\n      // we now only need to track this group name in groups.\n      delete preservedGroups[groupName]\n    }\n\n    var seen = {}\n    groups[groupName] = (existing || []).concat(opts).filter(function (key) {\n      if (seen[key]) return false\n      return (seen[key] = true)\n    })\n    return self\n  }\n  self.getGroups = function () {\n    // combine explicit and preserved groups. explicit groups should be first\n    return assign(groups, preservedGroups)\n  }\n\n  // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length)\n    if (prefix === false) options.envPrefix = undefined\n    else options.envPrefix = prefix || ''\n    return self\n  }\n\n  self.wrap = function (cols) {\n    argsert('<number|null>', [cols], arguments.length)\n    usage.wrap(cols)\n    return self\n  }\n\n  var strict = false\n  var strictGlobal = false\n  self.strict = function (global) {\n    argsert('[boolean]', [global], arguments.length)\n    strict = true\n    strictGlobal = global !== false\n    return self\n  }\n  self.getStrict = function () {\n    return strict\n  }\n\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length)\n    if (!self.parsed) self._parseArgs(processArgs) // run parser, if it has not already been executed.\n    usage.showHelp(level)\n    return self\n  }\n\n  var versionOpt = null\n  self.version = function (opt, msg, ver) {\n    argsert('[string|function] [string|function] [string]', [opt, msg, ver], arguments.length)\n    if (arguments.length === 0) {\n      ver = guessVersion()\n      opt = 'version'\n    } else if (arguments.length === 1) {\n      ver = opt\n      opt = 'version'\n    } else if (arguments.length === 2) {\n      ver = msg\n      msg = null\n    }\n\n    versionOpt = opt\n    msg = msg || usage.deferY18nLookup('Show version number')\n\n    usage.version(ver || undefined)\n    self.boolean(versionOpt)\n    self.describe(versionOpt, msg)\n    return self\n  }\n\n  function guessVersion () {\n    var obj = pkgUp()\n\n    return obj.version || 'unknown'\n  }\n\n  var helpOpt = null\n  var useHelpOptAsCommand = false // a call to .help() will enable this\n  self.addHelpOpt = self.help = function (opt, msg, addImplicitCmd) {\n    argsert('[string|boolean] [string|boolean] [boolean]', [opt, msg, addImplicitCmd], arguments.length)\n\n    // argument shuffle\n    if (arguments.length === 0) {\n      useHelpOptAsCommand = true\n    } else if (arguments.length === 1) {\n      if (typeof opt === 'boolean') {\n        useHelpOptAsCommand = opt\n        opt = null\n      } else {\n        useHelpOptAsCommand = true\n      }\n    } else if (arguments.length === 2) {\n      if (typeof msg === 'boolean') {\n        useHelpOptAsCommand = msg\n        msg = null\n      } else {\n        useHelpOptAsCommand = true\n      }\n    } else {\n      useHelpOptAsCommand = Boolean(addImplicitCmd)\n    }\n    // use arguments, fallback to defaults for opt and msg\n    helpOpt = opt || 'help'\n    self.boolean(helpOpt)\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'))\n    return self\n  }\n\n  self.showHelpOnFail = function (enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length)\n    usage.showHelpOnFail(enabled, message)\n    return self\n  }\n\n  var exitProcess = true\n  self.exitProcess = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length)\n    if (typeof enabled !== 'boolean') {\n      enabled = true\n    }\n    exitProcess = enabled\n    return self\n  }\n  self.getExitProcess = function () {\n    return exitProcess\n  }\n\n  var completionCommand = null\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length)\n\n    // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n    if (typeof desc === 'function') {\n      fn = desc\n      desc = null\n    }\n\n    // register the completion command.\n    completionCommand = cmd || 'completion'\n    if (!desc && desc !== false) {\n      desc = 'generate bash completion script'\n    }\n    self.command(completionCommand, desc)\n\n    // a function can be provided\n    if (fn) completion.registerFunction(fn)\n\n    return self\n  }\n\n  self.showCompletionScript = function ($0) {\n    argsert('[string]', [$0], arguments.length)\n    $0 = $0 || self.$0\n    _logger.log(completion.generateCompletionScript($0))\n    return self\n  }\n\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length)\n    completion.getCompletion(args, done)\n  }\n\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length)\n    if (arguments.length === 0) {\n      guessLocale()\n      return y18n.getLocale()\n    }\n    detectLocale = false\n    y18n.setLocale(locale)\n    return self\n  }\n\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length)\n    detectLocale = false\n    y18n.updateLocale(obj)\n    return self\n  }\n\n  var detectLocale = true\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length)\n    detectLocale = detect\n    return self\n  }\n  self.getDetectLocale = function () {\n    return detectLocale\n  }\n\n  var hasOutput = false\n  var exitError = null\n  // maybe exit, always capture\n  // context about why we wanted to exit.\n  self.exit = function (code, err) {\n    hasOutput = true\n    exitError = err\n    if (exitProcess) process.exit(code)\n  }\n\n  // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n  var _logger = {\n    log: function () {\n      const args = []\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i])\n      if (!self._hasParseCallback()) console.log.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    },\n    error: function () {\n      const args = []\n      for (var i = 0; i < arguments.length; i++) args.push(arguments[i])\n      if (!self._hasParseCallback()) console.error.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    }\n  }\n  self._getLoggerInstance = function () {\n    return _logger\n  }\n  // has yargs output an error our help\n  // message in the current execution context.\n  self._hasOutput = function () {\n    return hasOutput\n  }\n\n  self._setHasOutput = function () {\n    hasOutput = true\n  }\n\n  var recommendCommands\n  self.recommendCommands = function (recommend) {\n    argsert('[boolean]', [recommend], arguments.length)\n    recommendCommands = typeof recommend === 'boolean' ? recommend : true\n    return self\n  }\n\n  self.getUsageInstance = function () {\n    return usage\n  }\n\n  self.getValidationInstance = function () {\n    return validation\n  }\n\n  self.getCommandInstance = function () {\n    return command\n  }\n\n  self.terminalWidth = function () {\n    argsert([], 0)\n    return process.stdout.columns\n  }\n\n  Object.defineProperty(self, 'argv', {\n    get: function () {\n      return self._parseArgs(processArgs)\n    },\n    enumerable: true\n  })\n\n  self._parseArgs = function (args, shortCircuit, _skipValidation) {\n    var skipValidation = !!_skipValidation\n    args = args || processArgs\n\n    options.__ = y18n.__\n    options.configuration = pkgUp()['yargs'] || {}\n    const parsed = Parser.detailed(args, options)\n    var argv = parsed.argv\n    if (parseContext) argv = assign(argv, parseContext)\n    var aliases = parsed.aliases\n\n    argv.$0 = self.$0\n    self.parsed = parsed\n\n    try {\n      guessLocale() // guess locale lazily, so that it can be turned off in chain.\n\n      // while building up the argv object, there\n      // are two passes through the parser. If completion\n      // is being performed short-circuit on the first pass.\n      if (shortCircuit) {\n        return argv\n      }\n\n      if (argv._.length) {\n        // check for helpOpt in argv._ before running commands\n        // assumes helpOpt must be valid if useHelpOptAsCommand is true\n        if (useHelpOptAsCommand) {\n          // consider any multi-char helpOpt alias as a valid help command\n          // unless all helpOpt aliases are single-char\n          // note that parsed.aliases is a normalized bidirectional map :)\n          var helpCmds = [helpOpt].concat(aliases[helpOpt] || [])\n          var multiCharHelpCmds = helpCmds.filter(function (k) {\n            return k.length > 1\n          })\n          if (multiCharHelpCmds.length) helpCmds = multiCharHelpCmds\n          // look for and strip any helpCmds from argv._\n          argv._ = argv._.filter(function (cmd) {\n            if (~helpCmds.indexOf(cmd)) {\n              argv[helpOpt] = true\n              return false\n            }\n            return true\n          })\n        }\n\n        // if there's a handler associated with a\n        // command defer processing to it.\n        var handlerKeys = command.getCommands()\n        if (handlerKeys.length) {\n          var firstUnknownCommand\n          for (var i = 0, cmd; (cmd = argv._[i]) !== undefined; i++) {\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              setPlaceholderKeys(argv)\n              return command.runCommand(cmd, self, parsed)\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd\n            }\n          }\n\n          // run the default command, if defined\n          if (command.hasDefaultCommand() && !argv[helpOpt]) {\n            setPlaceholderKeys(argv)\n            return command.runCommand(null, self, parsed)\n          }\n\n          // recommend a command if recommendCommands() has\n          // been enabled, and no commands were found to execute\n          if (recommendCommands && firstUnknownCommand) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys)\n          }\n        }\n\n        // generate a completion script for adding to ~/.bashrc.\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {\n          if (exitProcess) setBlocking(true)\n          self.showCompletionScript()\n          self.exit(0)\n        }\n      } else if (command.hasDefaultCommand() && !argv[helpOpt]) {\n        setPlaceholderKeys(argv)\n        return command.runCommand(null, self, parsed)\n      }\n\n      // we must run completions first, a user might\n      // want to complete the --help or --version option.\n      if (completion.completionKey in argv) {\n        if (exitProcess) setBlocking(true)\n\n        // we allow for asynchronous completions,\n        // e.g., loading in a list of commands from an API.\n        var completionArgs = args.slice(args.indexOf('--' + completion.completionKey) + 1)\n        completion.getCompletion(completionArgs, function (completions) {\n          ;(completions || []).forEach(function (completion) {\n            _logger.log(completion)\n          })\n\n          self.exit(0)\n        })\n        return setPlaceholderKeys(argv)\n      }\n\n      // Handle 'help' and 'version' options\n      Object.keys(argv).forEach(function (key) {\n        if (key === helpOpt && argv[key]) {\n          if (exitProcess) setBlocking(true)\n\n          skipValidation = true\n          self.showHelp('log')\n          self.exit(0)\n        } else if (key === versionOpt && argv[key]) {\n          if (exitProcess) setBlocking(true)\n\n          skipValidation = true\n          usage.showVersion()\n          self.exit(0)\n        }\n      })\n\n      // Check if any of the options to skip validation were provided\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(function (key) {\n          return options.skipValidation.indexOf(key) >= 0 && argv[key] === true\n        })\n      }\n\n      // If the help or version options where used and exitProcess is false,\n      // or if explicitly skipped, we won't run validations.\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message)\n\n        // if we're executed via bash completion, don't\n        // bother with validation.\n        if (!argv[completion.completionKey]) {\n          self._runValidation(argv, aliases, {}, parsed.error)\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage.fail(err.message, err)\n      else throw err\n    }\n\n    return setPlaceholderKeys(argv)\n  }\n\n  self._runValidation = function (argv, aliases, positionalMap, parseErrors) {\n    if (parseErrors) throw new YError(parseErrors.message)\n    validation.nonOptionCount(argv)\n    validation.missingArgumentValue(argv)\n    validation.requiredArguments(argv)\n    if (strict) validation.unknownArguments(argv, aliases, positionalMap)\n    validation.customChecks(argv, aliases)\n    validation.limitedChoices(argv)\n    validation.implications(argv)\n    validation.conflicting(argv)\n  }\n\n  function guessLocale () {\n    if (!detectLocale) return\n\n    try {\n      const osLocale = require('os-locale')\n      self.locale(osLocale.sync({ spawn: false }))\n    } catch (err) {\n      // if we explode looking up locale just noop\n      // we'll keep using the default language 'en'.\n    }\n  }\n\n  function setPlaceholderKeys (argv) {\n    Object.keys(options.key).forEach(function (key) {\n      // don't set placeholder keys for dot\n      // notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  return self\n}\n\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nexports.rebase = rebase\nfunction rebase (base, dir) {\n  return path.relative(base, dir)\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/argsert.js":"const command = require('./command')()\nconst YError = require('./yerror')\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']\n\nmodule.exports = function (expected, callerArguments, length) {\n  // TODO: should this eventually raise an exception.\n  try {\n    // preface the argument description with \"cmd\", so\n    // that we can run it through yargs' command parser.\n    var position = 0\n    var parsed = {demanded: [], optional: []}\n    if (typeof expected === 'object') {\n      length = callerArguments\n      callerArguments = expected\n    } else {\n      parsed = command.parseCommand('cmd ' + expected)\n    }\n    const args = [].slice.call(callerArguments)\n\n    while (args.length && args[args.length - 1] === undefined) args.pop()\n    length = length || args.length\n\n    if (length < parsed.demanded.length) {\n      throw new YError('Not enough arguments provided. Expected ' + parsed.demanded.length +\n        ' but received ' + args.length + '.')\n    }\n\n    const totalCommands = parsed.demanded.length + parsed.optional.length\n    if (length > totalCommands) {\n      throw new YError('Too many arguments provided. Expected max ' + totalCommands +\n        ' but received ' + length + '.')\n    }\n\n    parsed.demanded.forEach(function (demanded) {\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = demanded.cmd.filter(function (type) {\n        return type === observedType || type === '*'\n      })\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false)\n      position += 1\n    })\n\n    parsed.optional.forEach(function (optional) {\n      if (args.length === 0) return\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = optional.cmd.filter(function (type) {\n        return type === observedType || type === '*'\n      })\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true)\n      position += 1\n    })\n  } catch (err) {\n    console.warn(err.stack)\n  }\n}\n\nfunction guessType (arg) {\n  if (Array.isArray(arg)) {\n    return 'array'\n  } else if (arg === null) {\n    return 'null'\n  }\n  return typeof arg\n}\n\nfunction argumentTypeError (observedType, allowedTypes, position, optional) {\n  throw new YError('Invalid ' + (positionName[position] || 'manyith') + ' argument.' +\n    ' Expected ' + allowedTypes.join(' or ') + ' but received ' + observedType + '.')\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/command.js":"const path = require('path')\nconst inspect = require('util').inspect\nconst camelCase = require('camelcase')\n\nconst DEFAULT_MARKER = '*'\n\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nmodule.exports = function (yargs, usage, validation) {\n  const self = {}\n\n  var handlers = {}\n  var aliasMap = {}\n  var defaultCommand\n  self.addHandler = function (cmd, description, builder, handler) {\n    var aliases = []\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1)\n      cmd = cmd[0]\n    } else if (typeof cmd === 'object') {\n      var command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler)\n      return\n    }\n\n    // allow a module to be provided instead of separate builder and handler\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler)\n      return\n    }\n\n    // parse positionals out of cmd string\n    var parsedCommand = self.parseCommand(cmd)\n\n    // remove positional args from aliases only\n    aliases = aliases.map(function (alias) {\n      return self.parseCommand(alias).cmd\n    })\n\n    // check for default and filter out '*''\n    var isDefault = false\n    var parsedAliases = [parsedCommand.cmd].concat(aliases).filter(function (c) {\n      if (c === DEFAULT_MARKER) {\n        isDefault = true\n        return false\n      }\n      return true\n    })\n\n    // short-circuit if default with no aliases\n    if (isDefault && parsedAliases.length === 0) {\n      defaultCommand = {\n        original: cmd.replace(DEFAULT_MARKER, '').trim(),\n        handler: handler,\n        builder: builder || {},\n        demanded: parsedCommand.demanded,\n        optional: parsedCommand.optional\n      }\n      return\n    }\n\n    // shift cmd and aliases after filtering out '*'\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0]\n      aliases = parsedAliases.slice(1)\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)\n    }\n\n    // populate aliasMap\n    aliases.forEach(function (alias) {\n      aliasMap[alias] = parsedCommand.cmd\n    })\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases)\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      handler: handler,\n      builder: builder || {},\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    }\n\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]\n  }\n\n  self.addDirectory = function (dir, context, req, callerFile, opts) {\n    opts = opts || {}\n    // disable recursion to support nested directories of subcommands\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false\n    // exclude 'json', 'coffee' from require-directory defaults\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']\n    // allow consumer to define their own visitor function\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) { return o }\n    // call addHandler via visitor function\n    opts.visit = function (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename)\n      // allow consumer to skip modules with their own visitor\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited\n        // keep track of visited files in context.files\n        context.files.push(joined)\n        self.addHandler(visited)\n      }\n      return visited\n    }\n    require('require-directory')({ require: req, filename: callerFile }, dir, opts)\n  }\n\n  // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n  function moduleName (obj) {\n    const mod = require('which-module')(obj)\n    if (!mod) throw new Error('No command name given for module: ' + inspect(obj))\n    return commandFromFilename(mod.filename)\n  }\n\n  // derive command name from filename\n  function commandFromFilename (filename) {\n    return path.basename(filename, path.extname(filename))\n  }\n\n  function extractDesc (obj) {\n    for (var keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]]\n      if (typeof test === 'string' || typeof test === 'boolean') return test\n    }\n    return false\n  }\n\n  self.parseCommand = function (cmd) {\n    var extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ')\n    var splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/)\n    var bregex = /\\.*[\\][<>]/g\n    var parsedCommand = {\n      cmd: (splitCommand.shift()).replace(bregex, ''),\n      demanded: [],\n      optional: []\n    }\n    splitCommand.forEach(function (cmd, i) {\n      var variadic = false\n      cmd = cmd.replace(/\\s/g, '')\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic: variadic\n        })\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic: variadic\n        })\n      }\n    })\n    return parsedCommand\n  }\n\n  self.getCommands = function () {\n    return Object.keys(handlers).concat(Object.keys(aliasMap))\n  }\n\n  self.getCommandHandlers = function () {\n    return handlers\n  }\n\n  self.hasDefaultCommand = function () {\n    return !!defaultCommand\n  }\n\n  self.runCommand = function (command, yargs, parsed) {\n    var aliases = parsed.aliases\n    var commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand\n    var currentContext = yargs.getContext()\n    var numFiles = currentContext.files.length\n    var parentCommands = currentContext.commands.slice()\n\n    // what does yargs look like after the buidler is run?\n    var innerArgv = parsed.argv\n    var innerYargs = null\n    var positionalMap = {}\n\n    if (command) currentContext.commands.push(command)\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))\n      // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n      if (yargs.parsed === false) {\n        if (typeof yargs.getUsageInstance().getUsage() === 'undefined') {\n          yargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)\n        }\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true) : yargs._parseArgs(null, null, true)\n      } else {\n        innerArgv = yargs.parsed.argv\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases\n      else aliases = yargs.parsed.aliases\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases)\n      innerYargs.usage('$0 ' + (parentCommands.length ? parentCommands.join(' ') + ' ' : '') + commandHandler.original)\n      Object.keys(commandHandler.builder).forEach(function (key) {\n        innerYargs.option(key, commandHandler.builder[key])\n      })\n      innerArgv = innerYargs._parseArgs(null, null, true)\n      aliases = innerYargs.parsed.aliases\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)\n    }\n\n    // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput()\n      commandHandler.handler(innerArgv)\n    }\n\n    if (command) currentContext.commands.pop()\n    numFiles = currentContext.files.length - numFiles\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)\n\n    return innerArgv\n  }\n\n  // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n  function populatePositionals (commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length) // nuke the current commands\n    var demanded = commandHandler.demanded.slice(0)\n    var optional = commandHandler.optional.slice(0)\n    var positionalMap = {}\n\n    validation.positionalCount(demanded.length, argv._.length)\n\n    while (demanded.length) {\n      var demand = demanded.shift()\n      populatePositional(demand, argv, yargs, positionalMap)\n    }\n\n    while (optional.length) {\n      var maybe = optional.shift()\n      populatePositional(maybe, argv, yargs, positionalMap)\n    }\n\n    argv._ = context.commands.concat(argv._)\n    return positionalMap\n  }\n\n  // populate a single positional argument and its\n  // aliases onto argv.\n  function populatePositional (positional, argv, yargs, positionalMap) {\n    // \"positional\" consists of the positional.cmd, an array representing\n    // the positional's name and aliases, and positional.variadic\n    // indicating whether or not it is a variadic array.\n    var variadics = null\n    var value = null\n    for (var i = 0, cmd; (cmd = positional.cmd[i]) !== undefined; i++) {\n      if (positional.variadic) {\n        if (variadics) argv[cmd] = variadics.slice(0)\n        else argv[cmd] = variadics = argv._.splice(0)\n      } else {\n        if (!value && !argv._.length) continue\n        if (value) argv[cmd] = value\n        else argv[cmd] = value = argv._.shift()\n      }\n      positionalMap[cmd] = true\n      postProcessPositional(yargs, argv, cmd)\n      addCamelCaseExpansions(argv, cmd)\n    }\n  }\n\n  // TODO move positional arg logic to yargs-parser and remove this duplication\n  function postProcessPositional (yargs, argv, key) {\n    var coerce = yargs.getOptions().coerce[key]\n    if (typeof coerce === 'function') {\n      try {\n        argv[key] = coerce(argv[key])\n      } catch (err) {\n        yargs.getUsageInstance().fail(err.message, err)\n      }\n    }\n  }\n\n  function addCamelCaseExpansions (argv, option) {\n    if (/-/.test(option)) {\n      const cc = camelCase(option)\n      if (typeof argv[option] === 'object') argv[cc] = argv[option].slice(0)\n      else argv[cc] = argv[option]\n    }\n  }\n\n  self.reset = function () {\n    handlers = {}\n    aliasMap = {}\n    defaultCommand = undefined\n    return self\n  }\n\n  // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n  var frozen\n  self.freeze = function () {\n    frozen = {}\n    frozen.handlers = handlers\n    frozen.aliasMap = aliasMap\n    frozen.defaultCommand = defaultCommand\n  }\n  self.unfreeze = function () {\n    handlers = frozen.handlers\n    aliasMap = frozen.aliasMap\n    defaultCommand = frozen.defaultCommand\n    frozen = undefined\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/yerror.js":"function YError (msg) {\n  this.name = 'YError'\n  this.message = msg || 'yargs error'\n  Error.captureStackTrace(this, YError)\n}\n\nYError.prototype = Object.create(Error.prototype)\nYError.prototype.constructor = YError\n\nmodule.exports = YError\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/assign.js":"// lazy Object.assign logic that only works for merging\n// two objects; eventually we should replace this with Object.assign.\nmodule.exports = function assign (defaults, configuration) {\n  var o = {}\n  configuration = configuration || {}\n\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k]\n  })\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k]\n  })\n\n  return o\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/completion.js":"const fs = require('fs')\nconst path = require('path')\n\n// add bash completions to your\n//  yargs-powered applications.\nmodule.exports = function (yargs, usage, command) {\n  const self = {\n    completionKey: 'get-yargs-completions'\n  }\n\n  // get a list of completion commands.\n  // 'args' is the array of strings from the line to be completed\n  self.getCompletion = function (args, done) {\n    const completions = []\n    const current = args.length ? args[args.length - 1] : ''\n    const argv = yargs.parse(args, true)\n    const aliases = yargs.parsed.aliases\n\n    // a custom completion function can be provided\n    // to completion().\n    if (completionFunction) {\n      if (completionFunction.length < 3) {\n        var result = completionFunction(current, argv)\n\n        // promise based completion function.\n        if (typeof result.then === 'function') {\n          return result.then(function (list) {\n            process.nextTick(function () { done(list) })\n          }).catch(function (err) {\n            process.nextTick(function () { throw err })\n          })\n        }\n\n        // synchronous completion function.\n        return done(result)\n      } else {\n        // asynchronous completion function\n        return completionFunction(current, argv, function (completions) {\n          done(completions)\n        })\n      }\n    }\n\n    var handlers = command.getCommandHandlers()\n    for (var i = 0, ii = args.length; i < ii; ++i) {\n      if (handlers[args[i]] && handlers[args[i]].builder) {\n        const builder = handlers[args[i]].builder\n        if (typeof builder === 'function') {\n          const y = yargs.reset()\n          builder(y)\n          return y.argv\n        }\n      }\n    }\n\n    if (!current.match(/^-/)) {\n      usage.getCommands().forEach(function (command) {\n        if (args.indexOf(command[0]) === -1) {\n          completions.push(command[0])\n        }\n      })\n    }\n\n    if (current.match(/^-/)) {\n      Object.keys(yargs.getOptions().key).forEach(function (key) {\n        // If the key and its aliases aren't in 'args', add the key to 'completions'\n        var keyAndAliases = [key].concat(aliases[key] || [])\n        var notInArgs = keyAndAliases.every(function (val) {\n          return args.indexOf('--' + val) === -1\n        })\n        if (notInArgs) {\n          completions.push('--' + key)\n        }\n      })\n    }\n\n    done(completions)\n  }\n\n  // generate the completion script to add to your .bashrc.\n  self.generateCompletionScript = function ($0) {\n    var script = fs.readFileSync(\n      path.resolve(__dirname, '../completion.sh.hbs'),\n      'utf-8'\n    )\n    var name = path.basename($0)\n\n    // add ./to applications not yet installed as bin.\n    if ($0.match(/\\.js$/)) $0 = './' + $0\n\n    script = script.replace(/{{app_name}}/g, name)\n    return script.replace(/{{app_path}}/g, $0)\n  }\n\n  // register a function to perform your own custom\n  // completions., this function can be either\n  // synchrnous or asynchronous.\n  var completionFunction = null\n  self.registerFunction = function (fn) {\n    completionFunction = fn\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/usage.js":"// this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\nconst stringWidth = require('string-width')\nconst objFilter = require('./obj-filter')\nconst setBlocking = require('set-blocking')\nconst YError = require('./yerror')\n\nmodule.exports = function (yargs, y18n) {\n  const __ = y18n.__\n  const self = {}\n\n  // methods for ouputting/building failure message.\n  var fails = []\n  self.failFn = function (f) {\n    fails.push(f)\n  }\n\n  var failMessage = null\n  var showHelpOnFail = true\n  self.showHelpOnFail = function (enabled, message) {\n    if (typeof enabled === 'string') {\n      message = enabled\n      enabled = true\n    } else if (typeof enabled === 'undefined') {\n      enabled = true\n    }\n    failMessage = message\n    showHelpOnFail = enabled\n    return self\n  }\n\n  var failureOutput = false\n  self.fail = function (msg, err) {\n    const logger = yargs._getLoggerInstance()\n\n    if (fails.length) {\n      for (var i = fails.length - 1; i >= 0; --i) {\n        fails[i](msg, err, self)\n      }\n    } else {\n      if (yargs.getExitProcess()) setBlocking(true)\n\n      // don't output failure message more than once\n      if (!failureOutput) {\n        failureOutput = true\n        if (showHelpOnFail) yargs.showHelp('error')\n        if (msg) logger.error(msg)\n        if (failMessage) {\n          if (msg) logger.error('')\n          logger.error(failMessage)\n        }\n      }\n\n      err = err || new YError(msg)\n      if (yargs.getExitProcess()) {\n        return yargs.exit(1)\n      } else if (yargs._hasParseCallback()) {\n        return yargs.exit(1, err)\n      } else {\n        throw err\n      }\n    }\n  }\n\n  // methods for ouputting/building help (usage) message.\n  var usage\n  self.usage = function (msg) {\n    usage = msg\n  }\n  self.getUsage = function () {\n    return usage\n  }\n\n  var examples = []\n  self.example = function (cmd, description) {\n    examples.push([cmd, description || ''])\n  }\n\n  var commands = []\n  self.command = function (cmd, description, isDefault, aliases) {\n    // the last default wins, so cancel out any previously set default\n    if (isDefault) {\n      commands = commands.map(function (cmdArray) {\n        cmdArray[2] = false\n        return cmdArray\n      })\n    }\n    commands.push([cmd, description || '', isDefault, aliases])\n  }\n  self.getCommands = function () {\n    return commands\n  }\n\n  var descriptions = {}\n  self.describe = function (key, desc) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.describe(k, key[k])\n      })\n    } else {\n      descriptions[key] = desc\n    }\n  }\n  self.getDescriptions = function () {\n    return descriptions\n  }\n\n  var epilog\n  self.epilog = function (msg) {\n    epilog = msg\n  }\n\n  var wrapSet = false\n  var wrap\n  self.wrap = function (cols) {\n    wrapSet = true\n    wrap = cols\n  }\n\n  function getWrap () {\n    if (!wrapSet) {\n      wrap = windowWidth()\n      wrapSet = true\n    }\n\n    return wrap\n  }\n\n  var deferY18nLookupPrefix = '__yargsString__:'\n  self.deferY18nLookup = function (str) {\n    return deferY18nLookupPrefix + str\n  }\n\n  var defaultGroup = 'Options:'\n  self.help = function () {\n    normalizeAliases()\n\n    // handle old demanded API\n    var demandedOptions = yargs.getDemandedOptions()\n    var demandedCommands = yargs.getDemandedCommands()\n    var groups = yargs.getGroups()\n    var options = yargs.getOptions()\n    var keys = Object.keys(\n      Object.keys(descriptions)\n      .concat(Object.keys(demandedOptions))\n      .concat(Object.keys(demandedCommands))\n      .concat(Object.keys(options.default))\n      .reduce(function (acc, key) {\n        if (key !== '_') acc[key] = true\n        return acc\n      }, {})\n    )\n\n    var theWrap = getWrap()\n    var ui = require('cliui')({\n      width: theWrap,\n      wrap: !!theWrap\n    })\n\n    // the usage string.\n    if (usage) {\n      var u = usage.replace(/\\$0/g, yargs.$0)\n      ui.div(u + '\\n')\n    }\n\n    // your application's commands, i.e., non-option\n    // arguments populated in '_'.\n    if (commands.length) {\n      ui.div(__('Commands:'))\n\n      commands.forEach(function (command) {\n        ui.span(\n          {text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands, theWrap) + 4},\n          {text: command[1]}\n        )\n        var hints = []\n        if (command[2]) hints.push('[' + __('default:').slice(0, -1) + ']') // TODO hacking around i18n here\n        if (command[3] && command[3].length) {\n          hints.push('[' + __('aliases:') + ' ' + command[3].join(', ') + ']')\n        }\n        if (hints.length) {\n          ui.div({text: hints.join(' '), padding: [0, 0, 0, 2], align: 'right'})\n        } else {\n          ui.div()\n        }\n      })\n\n      ui.div()\n    }\n\n    // perform some cleanup on the keys array, making it\n    // only include top-level keys not their aliases.\n    var aliasKeys = (Object.keys(options.alias) || [])\n      .concat(Object.keys(yargs.parsed.newAliases) || [])\n\n    keys = keys.filter(function (key) {\n      return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {\n        return (options.alias[alias] || []).indexOf(key) === -1\n      })\n    })\n\n    // populate 'Options:' group with any keys that have not\n    // explicitly had a group set.\n    if (!groups[defaultGroup]) groups[defaultGroup] = []\n    addUngroupedKeys(keys, options.alias, groups)\n\n    // display 'Options:' table along with any custom tables:\n    Object.keys(groups).forEach(function (groupName) {\n      if (!groups[groupName].length) return\n\n      ui.div(__(groupName))\n\n      // if we've grouped the key 'f', but 'f' aliases 'foobar',\n      // normalizedKeys should contain only 'foobar'.\n      var normalizedKeys = groups[groupName].map(function (key) {\n        if (~aliasKeys.indexOf(key)) return key\n        for (var i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey\n        }\n        return key\n      })\n\n      // actually generate the switches string --foo, -f, --bar.\n      var switches = normalizedKeys.reduce(function (acc, key) {\n        acc[key] = [ key ].concat(options.alias[key] || [])\n          .map(function (sw) {\n            return (sw.length > 1 ? '--' : '-') + sw\n          })\n          .join(', ')\n\n        return acc\n      }, {})\n\n      normalizedKeys.forEach(function (key) {\n        var kswitch = switches[key]\n        var desc = descriptions[key] || ''\n        var type = null\n\n        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length))\n\n        if (~options.boolean.indexOf(key)) type = '[' + __('boolean') + ']'\n        if (~options.count.indexOf(key)) type = '[' + __('count') + ']'\n        if (~options.string.indexOf(key)) type = '[' + __('string') + ']'\n        if (~options.normalize.indexOf(key)) type = '[' + __('string') + ']'\n        if (~options.array.indexOf(key)) type = '[' + __('array') + ']'\n        if (~options.number.indexOf(key)) type = '[' + __('number') + ']'\n\n        var extra = [\n          type,\n          (key in demandedOptions) ? '[' + __('required') + ']' : null,\n          options.choices && options.choices[key] ? '[' + __('choices:') + ' ' +\n            self.stringifiedValues(options.choices[key]) + ']' : null,\n          defaultString(options.default[key], options.defaultDescription[key])\n        ].filter(Boolean).join(' ')\n\n        ui.span(\n          {text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4},\n          desc\n        )\n\n        if (extra) ui.div({text: extra, padding: [0, 0, 0, 2], align: 'right'})\n        else ui.div()\n      })\n\n      ui.div()\n    })\n\n    // describe some common use-cases for your application.\n    if (examples.length) {\n      ui.div(__('Examples:'))\n\n      examples.forEach(function (example) {\n        example[0] = example[0].replace(/\\$0/g, yargs.$0)\n      })\n\n      examples.forEach(function (example) {\n        if (example[1] === '') {\n          ui.div(\n            {\n              text: example[0],\n              padding: [0, 2, 0, 2]\n            }\n          )\n        } else {\n          ui.div(\n            {\n              text: example[0],\n              padding: [0, 2, 0, 2],\n              width: maxWidth(examples, theWrap) + 4\n            }, {\n              text: example[1]\n            }\n          )\n        }\n      })\n\n      ui.div()\n    }\n\n    // the usage string.\n    if (epilog) {\n      var e = epilog.replace(/\\$0/g, yargs.$0)\n      ui.div(e + '\\n')\n    }\n\n    return ui.toString()\n  }\n\n  // return the maximum width of a string\n  // in the left-hand column of a table.\n  function maxWidth (table, theWrap) {\n    var width = 0\n\n    // table might be of the form [leftColumn],\n    // or {key: leftColumn}\n    if (!Array.isArray(table)) {\n      table = Object.keys(table).map(function (key) {\n        return [table[key]]\n      })\n    }\n\n    table.forEach(function (v) {\n      width = Math.max(stringWidth(v[0]), width)\n    })\n\n    // if we've enabled 'wrap' we should limit\n    // the max-width of the left-column.\n    if (theWrap) width = Math.min(width, parseInt(theWrap * 0.5, 10))\n\n    return width\n  }\n\n  // make sure any options set for aliases,\n  // are copied to the keys being aliased.\n  function normalizeAliases () {\n    // handle old demanded API\n    var demandedOptions = yargs.getDemandedOptions()\n    var options = yargs.getOptions()\n\n    ;(Object.keys(options.alias) || []).forEach(function (key) {\n      options.alias[key].forEach(function (alias) {\n        // copy descriptions.\n        if (descriptions[alias]) self.describe(key, descriptions[alias])\n        // copy demanded.\n        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias])\n        // type messages.\n        if (~options.boolean.indexOf(alias)) yargs.boolean(key)\n        if (~options.count.indexOf(alias)) yargs.count(key)\n        if (~options.string.indexOf(alias)) yargs.string(key)\n        if (~options.normalize.indexOf(alias)) yargs.normalize(key)\n        if (~options.array.indexOf(alias)) yargs.array(key)\n        if (~options.number.indexOf(alias)) yargs.number(key)\n      })\n    })\n  }\n\n  // given a set of keys, place any keys that are\n  // ungrouped under the 'Options:' grouping.\n  function addUngroupedKeys (keys, aliases, groups) {\n    var groupedKeys = []\n    var toCheck = null\n    Object.keys(groups).forEach(function (group) {\n      groupedKeys = groupedKeys.concat(groups[group])\n    })\n\n    keys.forEach(function (key) {\n      toCheck = [key].concat(aliases[key])\n      if (!toCheck.some(function (k) {\n        return groupedKeys.indexOf(k) !== -1\n      })) {\n        groups[defaultGroup].push(key)\n      }\n    })\n    return groupedKeys\n  }\n\n  self.showHelp = function (level) {\n    const logger = yargs._getLoggerInstance()\n    if (!level) level = 'error'\n    var emit = typeof level === 'function' ? level : logger[level]\n    emit(self.help())\n  }\n\n  self.functionDescription = function (fn) {\n    var description = fn.name ? require('decamelize')(fn.name, '-') : __('generated-value')\n    return ['(', description, ')'].join('')\n  }\n\n  self.stringifiedValues = function (values, separator) {\n    var string = ''\n    var sep = separator || ', '\n    var array = [].concat(values)\n\n    if (!values || !array.length) return string\n\n    array.forEach(function (value) {\n      if (string.length) string += sep\n      string += JSON.stringify(value)\n    })\n\n    return string\n  }\n\n  // format the default-value-string displayed in\n  // the right-hand column.\n  function defaultString (value, defaultDescription) {\n    var string = '[' + __('default:') + ' '\n\n    if (value === undefined && !defaultDescription) return null\n\n    if (defaultDescription) {\n      string += defaultDescription\n    } else {\n      switch (typeof value) {\n        case 'string':\n          string += JSON.stringify(value)\n          break\n        case 'object':\n          string += JSON.stringify(value)\n          break\n        default:\n          string += value\n      }\n    }\n\n    return string + ']'\n  }\n\n  // guess the width of the console window, max-width 80.\n  function windowWidth () {\n    var maxWidth = 80\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n      return Math.min(maxWidth, process.stdout.columns)\n    } else {\n      return maxWidth\n    }\n  }\n\n  // logic for displaying application version.\n  var version = null\n  self.version = function (ver) {\n    version = ver\n  }\n\n  self.showVersion = function () {\n    const logger = yargs._getLoggerInstance()\n    if (typeof version === 'function') logger.log(version())\n    else logger.log(version)\n  }\n\n  self.reset = function (localLookup) {\n    // do not reset wrap here\n    // do not reset fails here\n    failMessage = null\n    failureOutput = false\n    usage = undefined\n    epilog = undefined\n    examples = []\n    commands = []\n    descriptions = objFilter(descriptions, function (k, v) {\n      return !localLookup[k]\n    })\n    return self\n  }\n\n  var frozen\n  self.freeze = function () {\n    frozen = {}\n    frozen.failMessage = failMessage\n    frozen.failureOutput = failureOutput\n    frozen.usage = usage\n    frozen.epilog = epilog\n    frozen.examples = examples\n    frozen.commands = commands\n    frozen.descriptions = descriptions\n  }\n  self.unfreeze = function () {\n    failMessage = frozen.failMessage\n    failureOutput = frozen.failureOutput\n    usage = frozen.usage\n    epilog = frozen.epilog\n    examples = frozen.examples\n    commands = frozen.commands\n    descriptions = frozen.descriptions\n    frozen = undefined\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/obj-filter.js":"module.exports = function (original, filter) {\n  const obj = {}\n  filter = filter || function (k, v) { return true }\n  Object.keys(original || {}).forEach(function (key) {\n    if (filter(key, original[key])) {\n      obj[key] = original[key]\n    }\n  })\n  return obj\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/validation.js":"const objFilter = require('./obj-filter')\n\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nmodule.exports = function (yargs, usage, y18n) {\n  const __ = y18n.__\n  const __n = y18n.__n\n  const self = {}\n\n  // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n  self.nonOptionCount = function (argv) {\n    const demandedCommands = yargs.getDemandedCommands()\n    // don't count currently executing commands\n    const _s = argv._.length - yargs.getContext().commands.length\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null\n          )\n        } else {\n          usage.fail(\n            __('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min)\n          )\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null\n          )\n        } else {\n          usage.fail(\n          __('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max)\n          )\n        }\n      }\n    }\n  }\n\n  // validate the appropriate # of <required>\n  // positional arguments were provided:\n  self.positionalCount = function (required, observed) {\n    if (observed < required) {\n      usage.fail(\n        __('Not enough non-option arguments: got %s, need at least %s', observed, required)\n      )\n    }\n  }\n\n  // make sure that any args that require an\n  // value (--foo=bar), have a value.\n  self.missingArgumentValue = function (argv) {\n    const defaultValues = [true, false, '']\n    const options = yargs.getOptions()\n\n    if (options.requiresArg.length > 0) {\n      const missingRequiredArgs = []\n\n      options.requiresArg.forEach(function (key) {\n        const value = argv[key]\n\n        // if a value is explicitly requested,\n        // flag argument as missing if it does not\n        // look like foo=bar was entered.\n        if (~defaultValues.indexOf(value) ||\n          (Array.isArray(value) && !value.length)) {\n          missingRequiredArgs.push(key)\n        }\n      })\n\n      if (missingRequiredArgs.length > 0) {\n        usage.fail(__n(\n          'Missing argument value: %s',\n          'Missing argument values: %s',\n          missingRequiredArgs.length,\n          missingRequiredArgs.join(', ')\n        ))\n      }\n    }\n  }\n\n  // make sure all the required arguments are present.\n  self.requiredArguments = function (argv) {\n    const demandedOptions = yargs.getDemandedOptions()\n    var missing = null\n\n    Object.keys(demandedOptions).forEach(function (key) {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {}\n        missing[key] = demandedOptions[key]\n      }\n    })\n\n    if (missing) {\n      const customMsgs = []\n      Object.keys(missing).forEach(function (key) {\n        const msg = missing[key]\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg)\n        }\n      })\n\n      const customMsg = customMsgs.length ? '\\n' + customMsgs.join('\\n') : ''\n\n      usage.fail(__n(\n        'Missing required argument: %s',\n        'Missing required arguments: %s',\n        Object.keys(missing).length,\n        Object.keys(missing).join(', ') + customMsg\n      ))\n    }\n  }\n\n  // check for unknown arguments (strict-mode).\n  self.unknownArguments = function (argv, aliases, positionalMap) {\n    const aliasLookup = {}\n    const descriptions = usage.getDescriptions()\n    const demandedOptions = yargs.getDemandedOptions()\n    const commandKeys = yargs.getCommandInstance().getCommands()\n    const unknown = []\n    const currentContext = yargs.getContext()\n\n    Object.keys(aliases).forEach(function (key) {\n      aliases[key].forEach(function (alias) {\n        aliasLookup[alias] = key\n      })\n    })\n\n    Object.keys(argv).forEach(function (key) {\n      if (key !== '$0' && key !== '_' &&\n        !descriptions.hasOwnProperty(key) &&\n        !demandedOptions.hasOwnProperty(key) &&\n        !positionalMap.hasOwnProperty(key) &&\n        !yargs._getParseContext().hasOwnProperty(key) &&\n        !aliasLookup.hasOwnProperty(key)) {\n        unknown.push(key)\n      }\n    })\n\n    if (commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(function (key) {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key)\n        }\n      })\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n(\n        'Unknown argument: %s',\n        'Unknown arguments: %s',\n        unknown.length,\n        unknown.join(', ')\n      ))\n    }\n  }\n\n  // validate arguments limited to enumerated choices\n  self.limitedChoices = function (argv) {\n    const options = yargs.getOptions()\n    const invalid = {}\n\n    if (!Object.keys(options.choices).length) return\n\n    Object.keys(argv).forEach(function (key) {\n      if (key !== '$0' && key !== '_' &&\n        options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach(function (value) {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1) {\n            invalid[key] = (invalid[key] || []).concat(value)\n          }\n        })\n      }\n    })\n\n    const invalidKeys = Object.keys(invalid)\n\n    if (!invalidKeys.length) return\n\n    var msg = __('Invalid values:')\n    invalidKeys.forEach(function (key) {\n      msg += '\\n  ' + __(\n        'Argument: %s, Given: %s, Choices: %s',\n        key,\n        usage.stringifiedValues(invalid[key]),\n        usage.stringifiedValues(options.choices[key])\n      )\n    })\n    usage.fail(msg)\n  }\n\n  // custom checks, added using the `check` option on yargs.\n  var checks = []\n  self.check = function (f, global) {\n    checks.push({\n      func: f,\n      global: global\n    })\n  }\n\n  self.customChecks = function (argv, aliases) {\n    for (var i = 0, f; (f = checks[i]) !== undefined; i++) {\n      var func = f.func\n      var result = null\n      try {\n        result = func(argv, aliases)\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err)\n        continue\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()))\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result)\n      }\n    }\n  }\n\n  // check implications, argument foo implies => argument bar.\n  var implied = {}\n  self.implies = function (key, value) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.implies(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      implied[key] = value\n    }\n  }\n  self.getImplied = function () {\n    return implied\n  }\n\n  self.implications = function (argv) {\n    const implyFail = []\n\n    Object.keys(implied).forEach(function (key) {\n      var num\n      const origKey = key\n      var value = implied[key]\n\n      // convert string '1' to number 1\n      num = Number(key)\n      key = isNaN(num) ? key : num\n\n      if (typeof key === 'number') {\n        // check length of argv._\n        key = argv._.length >= key\n      } else if (key.match(/^--no-.+/)) {\n        // check if key doesn't exist\n        key = key.match(/^--no-(.+)/)[1]\n        key = !argv[key]\n      } else {\n        // check if key exists\n        key = argv[key]\n      }\n\n      num = Number(value)\n      value = isNaN(num) ? value : num\n\n      if (typeof value === 'number') {\n        value = argv._.length >= value\n      } else if (value.match(/^--no-.+/)) {\n        value = value.match(/^--no-(.+)/)[1]\n        value = !argv[value]\n      } else {\n        value = argv[value]\n      }\n\n      if (key && !value) {\n        implyFail.push(origKey)\n      }\n    })\n\n    if (implyFail.length) {\n      var msg = __('Implications failed:') + '\\n'\n\n      implyFail.forEach(function (key) {\n        msg += ('  ' + key + ' -> ' + implied[key])\n      })\n\n      usage.fail(msg)\n    }\n  }\n\n  var conflicting = {}\n  self.conflicts = function (key, value) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(function (k) {\n        self.conflicts(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      conflicting[key] = value\n    }\n  }\n  self.getConflicting = function () {\n    return conflicting\n  }\n\n  self.conflicting = function (argv) {\n    var args = Object.getOwnPropertyNames(argv)\n\n    args.forEach(function (arg) {\n      if (conflicting[arg] && args.indexOf(conflicting[arg]) !== -1) {\n        usage.fail(__('Arguments %s and %s are mutually exclusive', arg, conflicting[arg]))\n      }\n    })\n  }\n\n  self.recommendCommands = function (cmd, potentialCommands) {\n    const distance = require('./levenshtein')\n    const threshold = 3 // if it takes more than three edits, let's move on.\n    potentialCommands = potentialCommands.sort(function (a, b) { return b.length - a.length })\n\n    var recommended = null\n    var bestDistance = Infinity\n    for (var i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      var d = distance(cmd, candidate)\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d\n        recommended = candidate\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended))\n  }\n\n  self.reset = function (localLookup) {\n    implied = objFilter(implied, function (k, v) {\n      return !localLookup[k]\n    })\n    conflicting = objFilter(conflicting, function (k, v) {\n      return !localLookup[k]\n    })\n    checks = checks.filter(function (c) {\n      return c.global\n    })\n    return self\n  }\n\n  var frozen\n  self.freeze = function () {\n    frozen = {}\n    frozen.implied = implied\n    frozen.checks = checks\n    frozen.conflicting = conflicting\n  }\n  self.unfreeze = function () {\n    implied = frozen.implied\n    checks = frozen.checks\n    conflicting = frozen.conflicting\n    frozen = undefined\n  }\n\n  return self\n}\n","/home/travis/build/npmtest/node-npmtest-yargs/yargs/lib/apply-extends.js":"var fs = require('fs')\nvar path = require('path')\nvar assign = require('./assign')\nvar YError = require('./yerror')\n\nvar previouslyVisitedConfigs = []\n\nfunction checkForCircularExtends (path) {\n  if (previouslyVisitedConfigs.indexOf(path) > -1) {\n    throw new YError(\"Circular extended configurations: '\" + path + \"'.\")\n  }\n}\n\nfunction getPathToDefaultConfig (cwd, pathToExtend) {\n  return path.resolve(cwd, pathToExtend)\n}\n\nfunction applyExtends (config, cwd, subKey) {\n  var defaultConfig = {}\n\n  if (config.hasOwnProperty('extends')) {\n    var pathToDefault = getPathToDefaultConfig(cwd, config.extends)\n\n    checkForCircularExtends(pathToDefault)\n\n    previouslyVisitedConfigs.push(pathToDefault)\n    delete config.extends\n\n    defaultConfig = JSON.parse(fs.readFileSync(pathToDefault, 'utf8'))\n    if (subKey) {\n      defaultConfig = defaultConfig[subKey] || {}\n    }\n    defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault), subKey)\n  }\n\n  previouslyVisitedConfigs = []\n\n  return assign(defaultConfig, config)\n}\n\nmodule.exports = applyExtends\n"}